# Pig Gen
PigGen.exe is a small command-line utility meant to be used with [Pig Engine](https://github.com/PiggybankStudios/PigEngine). It collects all the .c and .h files within a speified folder tree, scans them for `#if PIGGEN` blocks, parses the pseudo-code inside the #if, and spits C code into a generated code folder, and then inserts a `#else` clause with a `#include "generated_code_name.h"` line inside to the original source code file (presumably the name of the generated file doesn't get changed very often so this should often result in no changes to the original source code)

## Invoking PigGen.exe

PigGen.exe takes one required argument which should be a path to a folder that contains one or more source code files (.c or .h), with all sub-directories of that folder being included in the generation process (unless excluded using the options below)

Other optional arguments take the form of `-name="value"` where the quotes are optional. Each argument should be separated by one space. In some instances, the value is optional as well, in which case `-name` is enough

### Arguments
* `help` / `h` - Displays this help message and then exits (other arguments are ignored)
* `version` - Prints the version number of PigGen and the exits (other arguments are ignored)
* `exclude="pattern"` - Exclude any files in the searched folder that match a given regular expression (multiple copies of this argument can be supplied)
* `verbose` - Enables a bunch of debug output lines that can help debug PigGen behavior

## Examples:

**piggen_examples.h**
```
#if PIGGEN
Serializable: ItemStack_t
{
	id:        u64
	flags:     u8
	itemId:    ItemId_t/u64
	count:     u64
	uiRec:     rec
	position:  v3?
}
#endif
```

Running PigGen.exe on the folder containing source_file.h will produce a new file:

**piggen_examples_h_0.h**
```
// This file was generated by PigGen.exe v0.01(283)
// Source: ../engine/piggen/piggen_examples.h
// Date: Friday 12:01:17pm (May 26th, 2023)

struct ItemStack_t
{
	u64 id;
	u8 flags;
	ItemId_t itemId;
	u64 count;
	rec uiRec;
	v3 position;
};

#define ItemStack_t_NumMembers 6
#define ItemStack_t_SlzSize ( \
	SlzMemberTypeSize_u64 + \
	SlzMemberTypeSize_u8 + \
	SlzMemberTypeSize_u64 + \
	SlzMemberTypeSize_u64 + \
	SlzMemberTypeSize_rec + \
	SlzMemberTypeSize_v3)

SlzMemberType_t SlzTypes_ItemStack_t[ItemStack_t_NumMembers] = {
	SlzMemberType_u64, //id
	SlzMemberType_u8, //flags
	SlzMemberType_u64, //itemId
	SlzMemberType_u64, //count
	SlzMemberType_rec, //uiRec
	SlzMemberType_v3, //position
};
const char* SlzNames_ItemStack_t[ItemStack_t_NumMembers] = {
	"id", //u64
	"flags", //u8
	"itemId", //ItemId_t
	"count", //u64
	"uiRec", //rec
	"position", //v3
};

SlzMemberType_t GetSerializableMemberType(const ItemStack_t* structPntr, u64 memberIndex)
{
	Assert(memberIndex < ItemStack_t_NumMembers);
	return SlzTypes_ItemStack_t[memberIndex];
}

const char* GetSerializableMemberName(const ItemStack_t* structPntr, u64 memberIndex)
{
	Assert(memberIndex < ItemStack_t_NumMembers);
	return SlzNames_ItemStack_t[memberIndex];
}

void* GetSerializableMemberPntr(ItemStack_t* structPntr, u64 memberIndex)
{
	switch (memberIndex)
	{
		case 0: return &structPntr->id;
		case 1: return &structPntr->flags;
		case 2: return &structPntr->itemId;
		case 3: return &structPntr->count;
		case 4: return &structPntr->uiRec;
		case 5: return &structPntr->position;
		default: Assert(false); return nullptr;
	}
}
const void* GetSerializableMemberPntr(const ItemStack_t* structPntr, u64 memberIndex) //const-variant
{
	return (const void*)GetSerializableMemberPntr((ItemStack_t*)structPntr, memberIndex);
}
```

PigGen.exe will also modify the original source code to become:

**piggen_examples.h (modified)**
```
#if PIGGEN
Serializable: ItemStack_t
{
	id:        u64
	flags:     u8
	itemId:    ItemId_t/u64
	count:     u64
	uiRec:     rec
	position:  v3?
}
#else
#include "piggen_examples_h_0.h"
#endif
```